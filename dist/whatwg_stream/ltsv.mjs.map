{"version":3,"file":"ltsv.mjs","names":[],"sources":["../../src/validator.ts","../../src/parser.ts","../../src/whatwg_stream.ts"],"sourcesContent":["/**\n * validate label\n *\n * @param label\n */\nexport function isValidLabel(label: string): boolean {\n  return /^[0-9A-Za-z_.-]+$/.test(label);\n}\n\n/**\n * validate for value\n *\n * @param value\n */\nexport function isValidValue(value: string): boolean {\n  // eslint-disable-next-line no-control-regex\n  return /^[\\x01-\\x08\\x0B\\x0C\\x0E-\\xFF]*$/.test(value);\n}\n","import type { LtsvRecord } from './types.js';\nimport { isValidLabel, isValidValue } from './validator.js';\n\ntype LtsvField = {\n  label: string;\n  value: string;\n};\n\n/**\n * split to label and value from field\n *\n * @private\n * @param chunk\n * @param strict\n * @throws {SyntaxError}\n * @throws {TypeError}\n */\nfunction splitField(chunk: string | undefined, strict: boolean): LtsvField {\n  if (chunk === undefined) {\n    throw new TypeError('chunk is undefined');\n  }\n\n  const index = chunk.indexOf(':');\n\n  if (index === -1) {\n    throw new SyntaxError(`field separator is not found: \"${chunk}\"`);\n  }\n\n  const label = chunk.slice(0, index);\n  const value = chunk.slice(index + 1);\n\n  if (strict && !isValidLabel(label)) {\n    throw new SyntaxError(`unexpected character in label: \"${label}\"`);\n  }\n\n  if (strict && !isValidValue(value)) {\n    throw new SyntaxError(`unexpected character in value: \"${value}\"`);\n  }\n\n  return {\n    label,\n    value\n  };\n}\n\n/**\n * parse LTSV record\n *\n * @private\n * @param line\n * @param strict\n */\nfunction baseParseLine(line: string | undefined, strict: boolean): LtsvRecord {\n  const fields = String(line)\n    .replace(/(?:\\r?\\n)+$/, '')\n    .split('\\t');\n\n  const record: LtsvRecord = {};\n\n  for (let i = 0, len = fields.length; i < len; ++i) {\n    const { label, value } = splitField(fields[i], strict);\n\n    record[label] = value;\n  }\n\n  return record;\n}\n\n/**\n * parse LTSV text\n *\n * @private\n * @param text\n * @param strict\n */\nfunction baseParse(text: string, strict: boolean): LtsvRecord[] {\n  const lines = String(text)\n    .replace(/(?:\\r?\\n)+$/, '')\n    .split(/\\r?\\n/);\n\n  const records: LtsvRecord[] = [];\n\n  for (let i = 0, len = lines.length; i < len; ++i) {\n    records[i] = baseParseLine(lines[i], strict);\n  }\n\n  return records;\n}\n\n/**\n * parse LTSV text\n *\n * @param text\n */\nexport function parse(text: string): LtsvRecord[] {\n  return baseParse(text, false);\n}\n\n/**\n * parse LTSV record\n *\n * @param line\n */\nexport function parseLine(line: string): LtsvRecord {\n  return baseParseLine(line, false);\n}\n\n/**\n * parse LTSV text\n *\n * @param text\n */\nexport function parseStrict(text: string): LtsvRecord[] {\n  return baseParse(text, true);\n}\n\n/**\n * parse LTSV record\n *\n * @param line\n */\nexport function parseLineStrict(line: string): LtsvRecord {\n  return baseParseLine(line, true);\n}\n","import { parseLine, parseLineStrict } from './parser.js';\nimport type { LtsvRecord } from './types.js';\n\nexport type LtsvToJsonStreamOptions = {\n  objectMode?: boolean;\n  strict?: boolean;\n};\n\ntype LtsvToJsonStreamInstance = {\n  buffer: string;\n  objectMode: boolean;\n  parse: typeof parseLine | typeof parseLineStrict;\n};\n\n/**\n * transform and push to stream\n *\n * @param text\n * @param isFlush\n * @param controller\n */\nfunction push(\n  this: LtsvToJsonStreamInstance,\n  text: string,\n  isFlush: boolean,\n  controller: TransformStreamDefaultController<string | LtsvRecord>\n): void {\n  let next = 0;\n  let last = 0;\n  let error: Error | null = null;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let index = text.indexOf('\\n', next);\n\n    if (index === -1) {\n      if (isFlush && next < text.length) {\n        // NOTE: subtract 1 from text.length,\n        // NOTE: because add 1 to index when slice.\n        index = text.length - 1;\n      } else {\n        break;\n      }\n    }\n\n    // NOTE: include `\\n`.\n    // NOTE: foo:foo\\tbar:bar\\nfoo:foo\\tbar:bar\\n\n    // NOTE: -----------------|\n    const line = text.slice(next, index + 1);\n\n    let record: LtsvRecord = {};\n\n    try {\n      record = this.parse(line);\n    } catch (e) {\n      if (e instanceof Error) {\n        error = e;\n      }\n    }\n\n    if (error) {\n      break;\n    }\n\n    controller.enqueue(this.objectMode ? record : JSON.stringify(record));\n\n    // NOTE: save next start index.\n    // NOTE: foo:foo\\tbar:bar\\nfoo:foo\\tbar:bar\\n\n    // NOTE: ------------------|\n    last = next = index + 1;\n  }\n\n  this.buffer = text.slice(last);\n\n  if (error) {\n    controller.error(error);\n  }\n}\n\n/**\n * LTSV to JSON transform stream\n *\n * @param options\n */\nexport function LtsvToJsonStream(\n  options: LtsvToJsonStreamOptions = {\n    objectMode: false,\n    strict: false\n  }\n): Transformer<string, string | LtsvRecord> {\n  const { objectMode = false, strict = false } = options;\n\n  const instance: LtsvToJsonStreamInstance = {\n    buffer: '',\n    objectMode,\n    parse: strict ? parseLineStrict : parseLine\n  };\n\n  return {\n    /**\n     * transform implementation.\n     *\n     * @param chunk\n     * @param controller\n     */\n    transform(\n      chunk: string,\n      controller: TransformStreamDefaultController<string | LtsvRecord>\n    ): void {\n      push.call(instance, instance.buffer + chunk, false, controller);\n    },\n    /**\n     * flush implementation.\n     *\n     * @param controller\n     */\n    flush(\n      controller: TransformStreamDefaultController<string | LtsvRecord>\n    ): void {\n      push.call(instance, instance.buffer, true, controller);\n    }\n  };\n}\n\nexport function createLtsvToJsonStream(\n  options?: LtsvToJsonStreamOptions\n): TransformStream<string, string | LtsvRecord> {\n  return new TransformStream(LtsvToJsonStream(options));\n}\n"],"mappings":";;;;;;AAKA,SAAgB,aAAa,OAAwB;AACnD,QAAO,oBAAoB,KAAK,MAAM;;;;;;;AAQxC,SAAgB,aAAa,OAAwB;AAEnD,QAAO,kCAAkC,KAAK,MAAM;;;;;;;;;;;;;;ACCtD,SAAS,WAAW,OAA2B,QAA4B;AACzE,KAAI,UAAU,OACZ,OAAM,IAAI,UAAU,qBAAqB;CAG3C,MAAM,QAAQ,MAAM,QAAQ,IAAI;AAEhC,KAAI,UAAU,GACZ,OAAM,IAAI,YAAY,kCAAkC,MAAM,GAAG;CAGnE,MAAM,QAAQ,MAAM,MAAM,GAAG,MAAM;CACnC,MAAM,QAAQ,MAAM,MAAM,QAAQ,EAAE;AAEpC,KAAI,UAAU,CAAC,aAAa,MAAM,CAChC,OAAM,IAAI,YAAY,mCAAmC,MAAM,GAAG;AAGpE,KAAI,UAAU,CAAC,aAAa,MAAM,CAChC,OAAM,IAAI,YAAY,mCAAmC,MAAM,GAAG;AAGpE,QAAO;EACL;EACA;EACD;;;;;;;;;AAUH,SAAS,cAAc,MAA0B,QAA6B;CAC5E,MAAM,SAAS,OAAO,KAAK,CACxB,QAAQ,eAAe,GAAG,CAC1B,MAAM,IAAK;CAEd,MAAM,SAAqB,EAAE;AAE7B,MAAK,IAAI,IAAI,GAAG,MAAM,OAAO,QAAQ,IAAI,KAAK,EAAE,GAAG;EACjD,MAAM,EAAE,OAAO,UAAU,WAAW,OAAO,IAAI,OAAO;AAEtD,SAAO,SAAS;;AAGlB,QAAO;;;;;;;AAsCT,SAAgB,UAAU,MAA0B;AAClD,QAAO,cAAc,MAAM,MAAM;;;;;;;AAiBnC,SAAgB,gBAAgB,MAA0B;AACxD,QAAO,cAAc,MAAM,KAAK;;;;;;;;;;;;ACrGlC,SAAS,KAEP,MACA,SACA,YACM;CACN,IAAI,OAAO;CACX,IAAI,OAAO;CACX,IAAI,QAAsB;AAG1B,QAAO,MAAM;EACX,IAAI,QAAQ,KAAK,QAAQ,MAAM,KAAK;AAEpC,MAAI,UAAU,GACZ,KAAI,WAAW,OAAO,KAAK,OAGzB,SAAQ,KAAK,SAAS;MAEtB;EAOJ,MAAM,OAAO,KAAK,MAAM,MAAM,QAAQ,EAAE;EAExC,IAAI,SAAqB,EAAE;AAE3B,MAAI;AACF,YAAS,KAAK,MAAM,KAAK;WAClB,GAAG;AACV,OAAI,aAAa,MACf,SAAQ;;AAIZ,MAAI,MACF;AAGF,aAAW,QAAQ,KAAK,aAAa,SAAS,KAAK,UAAU,OAAO,CAAC;AAKrE,SAAO,OAAO,QAAQ;;AAGxB,MAAK,SAAS,KAAK,MAAM,KAAK;AAE9B,KAAI,MACF,YAAW,MAAM,MAAM;;;;;;;AAS3B,SAAgB,iBACd,UAAmC;CACjC,YAAY;CACZ,QAAQ;CACT,EACyC;CAC1C,MAAM,EAAE,aAAa,OAAO,SAAS,UAAU;CAE/C,MAAM,WAAqC;EACzC,QAAQ;EACR;EACA,OAAO,SAAS,kBAAkB;EACnC;AAED,QAAO;EAOL,UACE,OACA,YACM;AACN,QAAK,KAAK,UAAU,SAAS,SAAS,OAAO,OAAO,WAAW;;EAOjE,MACE,YACM;AACN,QAAK,KAAK,UAAU,SAAS,QAAQ,MAAM,WAAW;;EAEzD;;AAGH,SAAgB,uBACd,SAC8C;AAC9C,QAAO,IAAI,gBAAgB,iBAAiB,QAAQ,CAAC"}