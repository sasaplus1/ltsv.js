{"version":3,"file":"ltsv.cjs","names":[],"sources":["../src/validator.ts","../src/formatter.ts","../src/parser.ts"],"sourcesContent":["/**\n * validate label\n *\n * @param label\n */\nexport function isValidLabel(label: string): boolean {\n  return /^[0-9A-Za-z_.-]+$/.test(label);\n}\n\n/**\n * validate for value\n *\n * @param value\n */\nexport function isValidValue(value: string): boolean {\n  // eslint-disable-next-line no-control-regex\n  return /^[\\x01-\\x08\\x0B\\x0C\\x0E-\\xFF]*$/.test(value);\n}\n","import type { LtsvRecord } from './types.js';\nimport { isValidLabel, isValidValue } from './validator.js';\n\nexport type StringifyOptions = {\n  strict: boolean;\n};\n\n/**\n * convert to record string from object\n *\n * @private\n * @param record\n * @param strict\n * @throws {TypeError}\n */\nfunction objectToRecord(record: LtsvRecord, strict: boolean): string {\n  if (record === null || typeof record !== 'object') {\n    throw new TypeError('record must be an Object');\n  }\n\n  const keys = Object.keys(record);\n  const fields = [];\n\n  for (let i = 0, len = keys.length; i < len; ++i) {\n    const label = keys[i];\n\n    if (!label) {\n      throw new TypeError('label must be a non-empty string');\n    }\n\n    const value = record[label];\n\n    if (!value) {\n      throw new TypeError('value must be a non-empty string');\n    }\n\n    if (strict && !isValidLabel(label)) {\n      throw new SyntaxError(`unexpected character in label: \"${label}\"`);\n    }\n\n    if (strict && !isValidValue(value)) {\n      throw new SyntaxError(`unexpected character in value: \"${value}\"`);\n    }\n\n    fields[i] = label + ':' + value;\n  }\n\n  return fields.join('\\t');\n}\n\n/**\n * convert to LTSV string from object or array\n *\n * @private\n * @param data\n * @param strict\n * @throws {TypeError}\n */\nfunction baseFormat(data: LtsvRecord | LtsvRecord[], strict: boolean): string {\n  const isArray = Array.isArray(data);\n\n  if (!isArray && (data === null || typeof data !== 'object')) {\n    throw new TypeError('data must be an Object or Array');\n  }\n\n  const records: string[] = [];\n\n  if (isArray) {\n    for (let i = 0, len = data.length; i < len; ++i) {\n      const record = data[i];\n\n      if (!record) {\n        throw new TypeError('record must be an Object');\n      }\n\n      records[i] = objectToRecord(record, strict);\n    }\n  } else {\n    records.push(objectToRecord(data as LtsvRecord, strict));\n  }\n\n  return records.join('\\n');\n}\n\n/**\n * convert to LTSV string from object or array\n *\n * @param data\n * @see baseFormat\n */\nexport function format(data: LtsvRecord | LtsvRecord[]): string {\n  return baseFormat(data, false);\n}\n\n/**\n * convert to LTSV string from object or array\n *\n * @param data\n * @see baseFormat\n */\nexport function formatStrict(data: LtsvRecord | LtsvRecord[]): string {\n  return baseFormat(data, true);\n}\n\n/**\n * convert to LTSV string from object or array\n *\n * @param data\n * @param options\n * @see baseFormat\n */\nexport function stringify(\n  data: LtsvRecord | LtsvRecord[],\n  options: StringifyOptions = { strict: false }\n): string {\n  const { strict = false } = options;\n\n  return baseFormat(data, strict);\n}\n","import type { LtsvRecord } from './types.js';\nimport { isValidLabel, isValidValue } from './validator.js';\n\ntype LtsvField = {\n  label: string;\n  value: string;\n};\n\n/**\n * split to label and value from field\n *\n * @private\n * @param chunk\n * @param strict\n * @throws {SyntaxError}\n * @throws {TypeError}\n */\nfunction splitField(chunk: string | undefined, strict: boolean): LtsvField {\n  if (chunk === undefined) {\n    throw new TypeError('chunk is undefined');\n  }\n\n  const index = chunk.indexOf(':');\n\n  if (index === -1) {\n    throw new SyntaxError(`field separator is not found: \"${chunk}\"`);\n  }\n\n  const label = chunk.slice(0, index);\n  const value = chunk.slice(index + 1);\n\n  if (strict && !isValidLabel(label)) {\n    throw new SyntaxError(`unexpected character in label: \"${label}\"`);\n  }\n\n  if (strict && !isValidValue(value)) {\n    throw new SyntaxError(`unexpected character in value: \"${value}\"`);\n  }\n\n  return {\n    label,\n    value\n  };\n}\n\n/**\n * parse LTSV record\n *\n * @private\n * @param line\n * @param strict\n */\nfunction baseParseLine(line: string | undefined, strict: boolean): LtsvRecord {\n  const fields = String(line)\n    .replace(/(?:\\r?\\n)+$/, '')\n    .split('\\t');\n\n  const record: LtsvRecord = {};\n\n  for (let i = 0, len = fields.length; i < len; ++i) {\n    const { label, value } = splitField(fields[i], strict);\n\n    record[label] = value;\n  }\n\n  return record;\n}\n\n/**\n * parse LTSV text\n *\n * @private\n * @param text\n * @param strict\n */\nfunction baseParse(text: string, strict: boolean): LtsvRecord[] {\n  const lines = String(text)\n    .replace(/(?:\\r?\\n)+$/, '')\n    .split(/\\r?\\n/);\n\n  const records: LtsvRecord[] = [];\n\n  for (let i = 0, len = lines.length; i < len; ++i) {\n    records[i] = baseParseLine(lines[i], strict);\n  }\n\n  return records;\n}\n\n/**\n * parse LTSV text\n *\n * @param text\n */\nexport function parse(text: string): LtsvRecord[] {\n  return baseParse(text, false);\n}\n\n/**\n * parse LTSV record\n *\n * @param line\n */\nexport function parseLine(line: string): LtsvRecord {\n  return baseParseLine(line, false);\n}\n\n/**\n * parse LTSV text\n *\n * @param text\n */\nexport function parseStrict(text: string): LtsvRecord[] {\n  return baseParse(text, true);\n}\n\n/**\n * parse LTSV record\n *\n * @param line\n */\nexport function parseLineStrict(line: string): LtsvRecord {\n  return baseParseLine(line, true);\n}\n"],"mappings":"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"}