{"version":3,"file":"ltsv.module.mjs","sources":["../src/validator.ts","../src/formatter.ts","../src/parser.ts"],"sourcesContent":["/**\n * validate label\n *\n * @param label\n */\nexport function isValidLabel(label: string): boolean {\n  return /^[0-9A-Za-z_.-]+$/.test(label);\n}\n\n/**\n * validate for value\n *\n * @param value\n */\nexport function isValidValue(value: string): boolean {\n  // eslint-disable-next-line no-control-regex\n  return /^[\\x01-\\x08\\x0B\\x0C\\x0E-\\xFF]*$/.test(value);\n}\n","import { isValidLabel, isValidValue } from './validator';\n\nimport { LtsvRecord } from './types';\n\nexport type StringifyOptions = {\n  strict: boolean;\n};\n\n/**\n * convert to record string from object\n *\n * @private\n * @param record\n * @param strict\n * @throws {TypeError}\n */\nfunction objectToRecord(record: LtsvRecord, strict: boolean): string {\n  if (record === null || typeof record !== 'object') {\n    throw new TypeError('record must be an Object');\n  }\n\n  const keys = Object.keys(record);\n  const fields = [];\n\n  for (let i = 0, len = keys.length; i < len; ++i) {\n    const label = keys[i];\n    const value = record[keys[i]];\n\n    if (strict && !isValidLabel(label)) {\n      throw new SyntaxError(`unexpected character in label: \"${label}\"`);\n    }\n\n    if (strict && !isValidValue(value)) {\n      throw new SyntaxError(`unexpected character in value: \"${value}\"`);\n    }\n\n    fields[i] = label + ':' + value;\n  }\n\n  return fields.join('\\t');\n}\n\n/**\n * convert to LTSV string from object or array\n *\n * @private\n * @param data\n * @param strict\n * @throws {TypeError}\n */\nfunction baseFormat(data: LtsvRecord | LtsvRecord[], strict: boolean): string {\n  const isArray = Array.isArray(data);\n\n  if (!isArray && (data === null || typeof data !== 'object')) {\n    throw new TypeError('data must be an Object or Array');\n  }\n\n  const records: string[] = [];\n\n  if (isArray) {\n    for (let i = 0, len = data.length; i < len; ++i) {\n      records[i] = objectToRecord((data as LtsvRecord[])[i], strict);\n    }\n  } else {\n    records.push(objectToRecord(data as LtsvRecord, strict));\n  }\n\n  return records.join('\\n');\n}\n\n/**\n * convert to LTSV string from object or array\n *\n * @param data\n * @see baseFormat\n */\nexport function format(data: LtsvRecord | LtsvRecord[]): string {\n  return baseFormat(data, false);\n}\n\n/**\n * convert to LTSV string from object or array\n *\n * @param data\n * @see baseFormat\n */\nexport function formatStrict(data: LtsvRecord | LtsvRecord[]): string {\n  return baseFormat(data, true);\n}\n\n/**\n * convert to LTSV string from object or array\n *\n * @param data\n * @param options\n * @see baseFormat\n */\nexport function stringify(\n  data: LtsvRecord | LtsvRecord[],\n  options: StringifyOptions = { strict: false }\n): string {\n  const { strict = false } = options;\n\n  return baseFormat(data, strict);\n}\n","import { isValidLabel, isValidValue } from './validator';\n\nimport { LtsvRecord } from './types';\n\ntype LtsvField = {\n  label: string;\n  value: string;\n};\n\n/**\n * split to label and value from field\n *\n * @private\n * @param chunk\n * @param strict\n * @throws {SyntaxError}\n */\nfunction splitField(chunk: string, strict: boolean): LtsvField {\n  const field = String(chunk);\n  const index = field.indexOf(':');\n\n  if (index === -1) {\n    throw new SyntaxError(`field separator is not found: \"${field}\"`);\n  }\n\n  const label = field.slice(0, index);\n  const value = field.slice(index + 1);\n\n  if (strict && !isValidLabel(label)) {\n    throw new SyntaxError(`unexpected character in label: \"${label}\"`);\n  }\n\n  if (strict && !isValidValue(value)) {\n    throw new SyntaxError(`unexpected character in value: \"${value}\"`);\n  }\n\n  return {\n    label,\n    value\n  };\n}\n\n/**\n * parse LTSV record\n *\n * @private\n * @param line\n * @param strict\n */\nfunction baseParseLine(line: string, strict: boolean): LtsvRecord {\n  const fields = String(line)\n    .replace(/(?:\\r?\\n)+$/, '')\n    .split('\\t');\n\n  const record: LtsvRecord = {};\n\n  for (let i = 0, len = fields.length; i < len; ++i) {\n    const { label, value } = splitField(fields[i], strict);\n\n    record[label] = value;\n  }\n\n  return record;\n}\n\n/**\n * parse LTSV text\n *\n * @private\n * @param text\n * @param strict\n */\nfunction baseParse(text: string, strict: boolean): LtsvRecord[] {\n  const lines = String(text)\n    .replace(/(?:\\r?\\n)+$/, '')\n    .split(/\\r?\\n/);\n\n  const records: LtsvRecord[] = [];\n\n  for (let i = 0, len = lines.length; i < len; ++i) {\n    records[i] = baseParseLine(lines[i], strict);\n  }\n\n  return records;\n}\n\n/**\n * parse LTSV text\n *\n * @param text\n */\nexport function parse(text: string): LtsvRecord[] {\n  return baseParse(text, false);\n}\n\n/**\n * parse LTSV record\n *\n * @param line\n */\nexport function parseLine(line: string): LtsvRecord {\n  return baseParseLine(line, false);\n}\n\n/**\n * parse LTSV text\n *\n * @param text\n */\nexport function parseStrict(text: string): LtsvRecord[] {\n  return baseParse(text, true);\n}\n\n/**\n * parse LTSV record\n *\n * @param line\n */\nexport function parseLineStrict(line: string): LtsvRecord {\n  return baseParseLine(line, true);\n}\n"],"names":["isValidLabel","label","test","isValidValue","value","objectToRecord","record","strict","TypeError","keys","Object","fields","i","len","length","SyntaxError","join","baseFormat","data","isArray","Array","records","push","format","formatStrict","stringify","options","_options$strict","splitField","chunk","field","String","index","indexOf","slice","baseParseLine","line","replace","split","_splitField","baseParse","text","lines","parse","parseLine","parseStrict","parseLineStrict"],"mappings":"SAKgBA,EAAaC,GAC3B,0BAA2BC,KAAKD,EAClC,UAOgBE,EAAaC,GAE3B,wCAAyCF,KAAKE,EAChD,CCDA,SAASC,EAAeC,EAAoBC,GAC1C,GAAe,OAAXD,GAAqC,iBAAXA,EAC5B,UAAUE,UAAU,4BAMtB,IAHA,IAAMC,EAAOC,OAAOD,KAAKH,GACnBK,EAAS,GAENC,EAAI,EAAGC,EAAMJ,EAAKK,OAAQF,EAAIC,IAAOD,EAAG,CAC/C,IAAMX,EAAQQ,EAAKG,GACbR,EAAQE,EAAOG,EAAKG,IAE1B,GAAIL,IAAWP,EAAaC,GAC1B,UAAUc,+CAA+Cd,OAG3D,GAAIM,IAAWJ,EAAaC,GAC1B,UAAUW,+CAA+CX,OAG3DO,EAAOC,GAAKX,EAAQ,IAAMG,EAG5B,OAAOO,EAAOK,KAAK,KACrB,CAUA,SAASC,EAAWC,EAAiCX,GACnD,IAAMY,EAAUC,MAAMD,QAAQD,GAE9B,IAAKC,IAAqB,OAATD,GAAiC,iBAATA,GACvC,UAAUV,UAAU,mCAGtB,IAAMa,EAAoB,GAE1B,GAAIF,EACF,IAAK,IAAIP,EAAI,EAAGC,EAAMK,EAAKJ,OAAQF,EAAIC,IAAOD,EAC5CS,EAAQT,GAAKP,EAAgBa,EAAsBN,GAAIL,QAGzDc,EAAQC,KAAKjB,EAAea,EAAoBX,IAGlD,OAAOc,EAAQL,KAAK,KACtB,UAQgBO,EAAOL,GACrB,OAAOD,EAAWC,GAAM,EAC1B,UAQgBM,EAAaN,GAC3B,OAAOD,EAAWC,GAAM,EAC1B,UASgBO,EACdP,EACAQ,YAAAA,IAAAA,EAA4B,CAAEnB,QAAQ,IAEtC,IAAkCoB,EAAPD,EAAnBnB,OAER,OAAOU,EAAWC,WAFJS,GAAQA,EAGxB,CCvFA,SAASC,EAAWC,EAAetB,GACjC,IAAMuB,EAAQC,OAAOF,GACfG,EAAQF,EAAMG,QAAQ,KAE5B,IAAe,IAAXD,EACF,UAAUjB,8CAA8Ce,OAG1D,IAAM7B,EAAQ6B,EAAMI,MAAM,EAAGF,GACvB5B,EAAQ0B,EAAMI,MAAMF,EAAQ,GAElC,GAAIzB,IAAWP,EAAaC,GAC1B,UAAUc,+CAA+Cd,OAG3D,GAAIM,IAAWJ,EAAaC,GAC1B,UAAUW,+CAA+CX,OAG3D,MAAO,CACLH,MAAAA,EACAG,MAAAA,EAEJ,CASA,SAAS+B,EAAcC,EAAc7B,GAOnC,IANA,IAAMI,EAASoB,OAAOK,GACnBC,QAAQ,cAAe,IACvBC,MAAM,MAEHhC,EAAqB,GAElBM,EAAI,EAAGC,EAAMF,EAAOG,OAAQF,EAAIC,IAAOD,EAAG,CACjD,IAAA2B,EAAyBX,EAAWjB,EAAOC,GAAIL,GAE/CD,EAFaiC,EAALtC,OAAYsC,EAALnC,MAKjB,OAAOE,CACT,CASA,SAASkC,EAAUC,EAAclC,GAO/B,IANA,IAAMmC,EAAQX,OAAOU,GAClBJ,QAAQ,cAAe,IACvBC,MAAM,SAEHjB,EAAwB,GAErBT,EAAI,EAAGC,EAAM6B,EAAM5B,OAAQF,EAAIC,IAAOD,EAC7CS,EAAQT,GAAKuB,EAAcO,EAAM9B,GAAIL,GAGvC,OAAOc,CACT,UAOgBsB,EAAMF,GACpB,OAAOD,EAAUC,GAAM,EACzB,UAOgBG,EAAUR,GACxB,OAAOD,EAAcC,GAAM,EAC7B,UAOgBS,EAAYJ,GAC1B,OAAOD,EAAUC,GAAM,EACzB,UAOgBK,EAAgBV,GAC9B,OAAOD,EAAcC,GAAM,EAC7B"}