{"version":3,"file":"ltsv.js","sources":["../../src/validator.ts","../../src/formatter.ts","../../src/parser.ts","../../src/whatwg_stream.ts"],"sourcesContent":["/**\n * validate label\n *\n * @param label\n */\nexport function isValidLabel(label: string): boolean {\n  return /^[0-9A-Za-z_.-]+$/.test(label);\n}\n\n/**\n * validate for value\n *\n * @param value\n */\nexport function isValidValue(value: string): boolean {\n  // eslint-disable-next-line no-control-regex\n  return /^[\\x01-\\x08\\x0B\\x0C\\x0E-\\xFF]*$/.test(value);\n}\n","import { isValidLabel, isValidValue } from './validator';\n\nimport { LtsvRecord } from './types';\n\nexport type StringifyOptions = {\n  strict: boolean;\n};\n\n/**\n * convert to record string from object\n *\n * @private\n * @param record\n * @param strict\n * @throws {TypeError}\n */\nfunction objectToRecord(record: LtsvRecord, strict: boolean): string {\n  if (record === null || typeof record !== 'object') {\n    throw new TypeError('record must be an Object');\n  }\n\n  const keys = Object.keys(record);\n  const fields = [];\n\n  for (let i = 0, len = keys.length; i < len; ++i) {\n    const label = keys[i];\n    const value = record[keys[i]];\n\n    if (strict && !isValidLabel(label)) {\n      throw new SyntaxError(`unexpected character in label: \"${label}\"`);\n    }\n\n    if (strict && !isValidValue(value)) {\n      throw new SyntaxError(`unexpected character in value: \"${value}\"`);\n    }\n\n    fields[i] = label + ':' + value;\n  }\n\n  return fields.join('\\t');\n}\n\n/**\n * convert to LTSV string from object or array\n *\n * @private\n * @param data\n * @param strict\n * @throws {TypeError}\n */\nfunction baseFormat(data: LtsvRecord | LtsvRecord[], strict: boolean): string {\n  const isArray = Array.isArray(data);\n\n  if (!isArray && (data === null || typeof data !== 'object')) {\n    throw new TypeError('data must be an Object or Array');\n  }\n\n  const records: string[] = [];\n\n  if (isArray) {\n    for (let i = 0, len = data.length; i < len; ++i) {\n      records[i] = objectToRecord((data as LtsvRecord[])[i], strict);\n    }\n  } else {\n    records.push(objectToRecord(data as LtsvRecord, strict));\n  }\n\n  return records.join('\\n');\n}\n\n/**\n * convert to LTSV string from object or array\n *\n * @param data\n * @see baseFormat\n */\nexport function format(data: LtsvRecord | LtsvRecord[]): string {\n  return baseFormat(data, false);\n}\n\n/**\n * convert to LTSV string from object or array\n *\n * @param data\n * @see baseFormat\n */\nexport function formatStrict(data: LtsvRecord | LtsvRecord[]): string {\n  return baseFormat(data, true);\n}\n\n/**\n * convert to LTSV string from object or array\n *\n * @param data\n * @param options\n * @see baseFormat\n */\nexport function stringify(\n  data: LtsvRecord | LtsvRecord[],\n  options: StringifyOptions = { strict: false }\n): string {\n  const { strict = false } = options;\n\n  return baseFormat(data, strict);\n}\n","import { isValidLabel, isValidValue } from './validator';\n\nimport { LtsvRecord } from './types';\n\ntype LtsvField = {\n  label: string;\n  value: string;\n};\n\n/**\n * split to label and value from field\n *\n * @private\n * @param chunk\n * @param strict\n * @throws {SyntaxError}\n */\nfunction splitField(chunk: string, strict: boolean): LtsvField {\n  const field = String(chunk);\n  const index = field.indexOf(':');\n\n  if (index === -1) {\n    throw new SyntaxError(`field separator is not found: \"${field}\"`);\n  }\n\n  const label = field.slice(0, index);\n  const value = field.slice(index + 1);\n\n  if (strict && !isValidLabel(label)) {\n    throw new SyntaxError(`unexpected character in label: \"${label}\"`);\n  }\n\n  if (strict && !isValidValue(value)) {\n    throw new SyntaxError(`unexpected character in value: \"${value}\"`);\n  }\n\n  return {\n    label,\n    value\n  };\n}\n\n/**\n * parse LTSV record\n *\n * @private\n * @param line\n * @param strict\n */\nfunction baseParseLine(line: string, strict: boolean): LtsvRecord {\n  const fields = String(line)\n    .replace(/(?:\\r?\\n)+$/, '')\n    .split('\\t');\n\n  const record: LtsvRecord = {};\n\n  for (let i = 0, len = fields.length; i < len; ++i) {\n    const { label, value } = splitField(fields[i], strict);\n\n    record[label] = value;\n  }\n\n  return record;\n}\n\n/**\n * parse LTSV text\n *\n * @private\n * @param text\n * @param strict\n */\nfunction baseParse(text: string, strict: boolean): LtsvRecord[] {\n  const lines = String(text)\n    .replace(/(?:\\r?\\n)+$/, '')\n    .split(/\\r?\\n/);\n\n  const records: LtsvRecord[] = [];\n\n  for (let i = 0, len = lines.length; i < len; ++i) {\n    records[i] = baseParseLine(lines[i], strict);\n  }\n\n  return records;\n}\n\n/**\n * parse LTSV text\n *\n * @param text\n */\nexport function parse(text: string): LtsvRecord[] {\n  return baseParse(text, false);\n}\n\n/**\n * parse LTSV record\n *\n * @param line\n */\nexport function parseLine(line: string): LtsvRecord {\n  return baseParseLine(line, false);\n}\n\n/**\n * parse LTSV text\n *\n * @param text\n */\nexport function parseStrict(text: string): LtsvRecord[] {\n  return baseParse(text, true);\n}\n\n/**\n * parse LTSV record\n *\n * @param line\n */\nexport function parseLineStrict(line: string): LtsvRecord {\n  return baseParseLine(line, true);\n}\n","import { parseLine, parseLineStrict } from './parser';\nimport { LtsvRecord } from './types';\n\nexport type LtsvToJsonStreamOptions = {\n  objectMode?: boolean;\n  strict?: boolean;\n};\n\ntype LtsvToJsonStreamInstance = {\n  buffer: string;\n  objectMode: boolean;\n  parse: typeof parseLine | typeof parseLineStrict;\n};\n\n/**\n * transform and push to stream\n *\n * @param text\n * @param isFlush\n * @param controller\n */\nfunction push(\n  this: LtsvToJsonStreamInstance,\n  text: string,\n  isFlush: boolean,\n  controller: TransformStreamDefaultController<string | LtsvRecord>\n): void {\n  let next = 0;\n  let last = 0;\n  let error: Error | null = null;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let index = text.indexOf('\\n', next);\n\n    if (index === -1) {\n      if (isFlush && next < text.length) {\n        // NOTE: subtract 1 from text.length,\n        // NOTE: because add 1 to index when slice.\n        index = text.length - 1;\n      } else {\n        break;\n      }\n    }\n\n    // NOTE: include `\\n`.\n    // NOTE: foo:foo\\tbar:bar\\nfoo:foo\\tbar:bar\\n\n    // NOTE: -----------------|\n    const line = text.slice(next, index + 1);\n\n    let record: LtsvRecord = {};\n\n    try {\n      record = this.parse(line);\n    } catch (e) {\n      error = e;\n    }\n\n    if (error) {\n      break;\n    }\n\n    controller.enqueue(this.objectMode ? record : JSON.stringify(record));\n\n    // NOTE: save next start index.\n    // NOTE: foo:foo\\tbar:bar\\nfoo:foo\\tbar:bar\\n\n    // NOTE: ------------------|\n    last = next = index + 1;\n  }\n\n  this.buffer = text.slice(last);\n\n  if (error) {\n    controller.error(error);\n  }\n}\n\n/**\n * LTSV to JSON transform stream\n *\n * @param options\n */\nexport function LtsvToJsonStream(\n  options: LtsvToJsonStreamOptions = {\n    objectMode: false,\n    strict: false\n  }\n): Transformer<string, string | LtsvRecord> {\n  const { objectMode = false, strict = false } = options;\n\n  const instance: LtsvToJsonStreamInstance = {\n    buffer: '',\n    objectMode,\n    parse: strict ? parseLineStrict : parseLine\n  };\n\n  return {\n    /**\n     * transform implementation.\n     *\n     * @param chunk\n     * @param controller\n     */\n    transform(\n      chunk: string,\n      controller: TransformStreamDefaultController<string | LtsvRecord>\n    ): void {\n      push.call(instance, instance.buffer + chunk, false, controller);\n    },\n    /**\n     * flush implementation.\n     *\n     * @param controller\n     */\n    flush(\n      controller: TransformStreamDefaultController<string | LtsvRecord>\n    ): void {\n      push.call(instance, instance.buffer, true, controller);\n    }\n  };\n}\n\nexport function createLtsvToJsonStream(\n  options?: LtsvToJsonStreamOptions\n): TransformStream<string, string | LtsvRecord> {\n  return new TransformStream(LtsvToJsonStream(options));\n}\n"],"names":[],"mappings":"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"}