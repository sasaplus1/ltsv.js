function r(r){return/^[0-9A-Za-z_.-]+$/.test(r)}function n(r){return/^[\x01-\x08\x0B\x0C\x0E-\xFF]*$/.test(r)}function t(t,e){if(null===t||"object"!=typeof t)throw new TypeError("record must be an Object");const o=Object.keys(t),c=[];for(let i=0,u=o.length;i<u;++i){const u=o[i];if(!u)throw new TypeError("label must be a non-empty string");const a=t[u];if(!a)throw new TypeError("value must be a non-empty string");if(e&&!r(u))throw new SyntaxError(`unexpected character in label: "${u}"`);if(e&&!n(a))throw new SyntaxError(`unexpected character in value: "${a}"`);c[i]=u+":"+a}return c.join("\t")}function e(r,n){const e=Array.isArray(r);if(!e&&(null===r||"object"!=typeof r))throw new TypeError("data must be an Object or Array");const o=[];if(e)for(let e=0,c=r.length;e<c;++e){const c=r[e];if(!c)throw new TypeError("record must be an Object");o[e]=t(c,n)}else o.push(t(r,n));return o.join("\n")}function o(r){return e(r,!1)}function c(r){return e(r,!0)}function i(r,n={strict:!1}){const{strict:t=!1}=n;return e(r,t)}function u(t,e){if(void 0===t)throw new TypeError("chunk is undefined");const o=t.indexOf(":");if(-1===o)throw new SyntaxError(`field separator is not found: "${t}"`);const c=t.slice(0,o),i=t.slice(o+1);if(e&&!r(c))throw new SyntaxError(`unexpected character in label: "${c}"`);if(e&&!n(i))throw new SyntaxError(`unexpected character in value: "${i}"`);return{label:c,value:i}}function a(r,n){const t=String(r).replace(/(?:\r?\n)+$/,"").split("\t"),e={};for(let r=0,o=t.length;r<o;++r){const{label:o,value:c}=u(t[r],n);e[o]=c}return e}function f(r,n){const t=String(r).replace(/(?:\r?\n)+$/,"").split(/\r?\n/),e=[];for(let r=0,o=t.length;r<o;++r)e[r]=a(t[r],n);return e}function l(r){return f(r,!1)}function s(r){return a(r,!1)}function w(r){return f(r,!0)}function h(r){return a(r,!0)}export{o as format,c as formatStrict,r as isValidLabel,n as isValidValue,l as parse,s as parseLine,h as parseLineStrict,w as parseStrict,i as stringify};
//# sourceMappingURL=ltsv.modern.mjs.map
