{"version":3,"file":"ltsv.js","sources":["../../src/validator.ts","../../src/parser.ts","../../src/nodejs_stream.ts"],"sourcesContent":["/**\n * validate label\n *\n * @param label\n */\nexport function isValidLabel(label: string): boolean {\n  return /^[0-9A-Za-z_.-]+$/.test(label);\n}\n\n/**\n * validate for value\n *\n * @param value\n */\nexport function isValidValue(value: string): boolean {\n  // eslint-disable-next-line no-control-regex\n  return /^[\\x01-\\x08\\x0B\\x0C\\x0E-\\xFF]*$/.test(value);\n}\n","import { isValidLabel, isValidValue } from './validator';\n\nimport { LtsvRecord } from './types';\n\ntype LtsvField = {\n  label: string;\n  value: string;\n};\n\n/**\n * split to label and value from field\n *\n * @private\n * @param chunk\n * @param strict\n * @throws {SyntaxError}\n * @throws {TypeError}\n */\nfunction splitField(chunk: string | undefined, strict: boolean): LtsvField {\n  if (chunk === undefined) {\n    throw new TypeError('chunk is undefined');\n  }\n\n  const index = chunk.indexOf(':');\n\n  if (index === -1) {\n    throw new SyntaxError(`field separator is not found: \"${chunk}\"`);\n  }\n\n  const label = chunk.slice(0, index);\n  const value = chunk.slice(index + 1);\n\n  if (strict && !isValidLabel(label)) {\n    throw new SyntaxError(`unexpected character in label: \"${label}\"`);\n  }\n\n  if (strict && !isValidValue(value)) {\n    throw new SyntaxError(`unexpected character in value: \"${value}\"`);\n  }\n\n  return {\n    label,\n    value\n  };\n}\n\n/**\n * parse LTSV record\n *\n * @private\n * @param line\n * @param strict\n */\nfunction baseParseLine(line: string | undefined, strict: boolean): LtsvRecord {\n  const fields = String(line)\n    .replace(/(?:\\r?\\n)+$/, '')\n    .split('\\t');\n\n  const record: LtsvRecord = {};\n\n  for (let i = 0, len = fields.length; i < len; ++i) {\n    const { label, value } = splitField(fields[i], strict);\n\n    record[label] = value;\n  }\n\n  return record;\n}\n\n/**\n * parse LTSV text\n *\n * @private\n * @param text\n * @param strict\n */\nfunction baseParse(text: string, strict: boolean): LtsvRecord[] {\n  const lines = String(text)\n    .replace(/(?:\\r?\\n)+$/, '')\n    .split(/\\r?\\n/);\n\n  const records: LtsvRecord[] = [];\n\n  for (let i = 0, len = lines.length; i < len; ++i) {\n    records[i] = baseParseLine(lines[i], strict);\n  }\n\n  return records;\n}\n\n/**\n * parse LTSV text\n *\n * @param text\n */\nexport function parse(text: string): LtsvRecord[] {\n  return baseParse(text, false);\n}\n\n/**\n * parse LTSV record\n *\n * @param line\n */\nexport function parseLine(line: string): LtsvRecord {\n  return baseParseLine(line, false);\n}\n\n/**\n * parse LTSV text\n *\n * @param text\n */\nexport function parseStrict(text: string): LtsvRecord[] {\n  return baseParse(text, true);\n}\n\n/**\n * parse LTSV record\n *\n * @param line\n */\nexport function parseLineStrict(line: string): LtsvRecord {\n  return baseParseLine(line, true);\n}\n","import { Transform, TransformCallback } from 'stream';\nimport { StringDecoder } from 'string_decoder';\n\nimport { parseLine, parseLineStrict } from './parser';\nimport { LtsvRecord } from './types';\n\nexport type LtsvToJsonStreamOptions = {\n  encoding?: BufferEncoding;\n  objectMode?: boolean;\n  strict?: boolean;\n};\n\n/**\n * LTSV to JSON transform stream\n */\nexport class LtsvToJsonStream extends Transform {\n  /**\n   * chunk buffer\n   */\n  buffer: string;\n  /**\n   * for decode chunks\n   */\n  decoder: StringDecoder;\n  /**\n   * if true, pass object to next stream\n   */\n  objectMode: boolean;\n  /**\n   * parser function\n   */\n  parse: typeof parseLine | typeof parseLineStrict;\n\n  /**\n   * constructor\n   *\n   * @param options\n   */\n  constructor(\n    options: LtsvToJsonStreamOptions = {\n      encoding: 'utf8',\n      objectMode: false,\n      strict: false\n    }\n  ) {\n    super({\n      ...options,\n      decodeStrings: true,\n      objectMode: true\n    });\n\n    const { encoding = 'utf8', objectMode = false, strict = false } = options;\n\n    this.objectMode = objectMode;\n    this.parse = strict ? parseLineStrict : parseLine;\n\n    this.buffer = '';\n    this.decoder = new StringDecoder(encoding);\n  }\n\n  /**\n   * transform and push to stream.\n   *\n   * @private\n   * @param text\n   * @param isFlush\n   * @param callback\n   */\n  _push(text: string, isFlush: boolean, callback: TransformCallback): void {\n    let next = 0;\n    let last = 0;\n    let error: Error | null = null;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      let index = text.indexOf('\\n', next);\n\n      if (index === -1) {\n        if (isFlush && next < text.length) {\n          // NOTE: subtract 1 from text.length,\n          // NOTE: because add 1 to index when slice.\n          index = text.length - 1;\n        } else {\n          break;\n        }\n      }\n\n      // NOTE: include `\\n`.\n      // NOTE: foo:foo\\tbar:bar\\nfoo:foo\\tbar:bar\\n\n      // NOTE: -----------------|\n      const line = text.slice(next, index + 1);\n\n      let record: LtsvRecord = {};\n\n      try {\n        record = this.parse(line);\n      } catch (e) {\n        if (e instanceof Error) {\n          error = e;\n        }\n      }\n\n      if (error) {\n        break;\n      }\n\n      const result = this.push(\n        this.objectMode ? record : JSON.stringify(record)\n      );\n\n      if (result) {\n        // NOTE: save next start index.\n        // NOTE: foo:foo\\tbar:bar\\nfoo:foo\\tbar:bar\\n\n        // NOTE: ------------------|\n        last = next = index + 1;\n      } else {\n        break;\n      }\n    }\n\n    this.buffer = text.slice(last);\n\n    callback(error);\n  }\n\n  /**\n   * _transform implementation.\n   *\n   * @private\n   * @param chunk\n   * @param encoding\n   * @param callback\n   */\n  override _transform(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    chunk: any,\n    _encoding: BufferEncoding,\n    callback: TransformCallback\n  ): void {\n    this._push(this.buffer + this.decoder.write(chunk), false, callback);\n  }\n\n  /**\n   * _flush implementation.\n   *\n   * @private\n   * @param callback\n   */\n  override _flush(callback: TransformCallback): void {\n    this._push(this.buffer + this.decoder.end(), true, callback);\n  }\n}\n\n/**\n * create LtsvToJsonStream instance.\n *\n * @param options\n * @see LtsvToJsonStream\n */\nexport function createLtsvToJsonStream(\n  options?: LtsvToJsonStreamOptions\n): LtsvToJsonStream {\n  return new LtsvToJsonStream(options);\n}\n"],"names":["isValidLabel","label","test","isValidValue","value","splitField","chunk","strict","undefined","TypeError","index","indexOf","SyntaxError","slice","baseParseLine","line","fields","String","replace","split","record","i","len","length","parseLine","parseLineStrict","LtsvToJsonStream","Transform","constructor","options","encoding","objectMode","decodeStrings","buffer","decoder","parse","StringDecoder","_push","text","isFlush","callback","next","last","error","e","Error","result","push","JSON","stringify","_transform","_encoding","write","_flush","end","createLtsvToJsonStream"],"mappings":"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"}