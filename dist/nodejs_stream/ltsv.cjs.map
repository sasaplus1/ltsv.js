{"version":3,"file":"ltsv.cjs","names":["Transform","StringDecoder"],"sources":["../../src/validator.ts","../../src/parser.ts","../../src/nodejs_stream.ts"],"sourcesContent":["/**\n * validate label\n *\n * @param label\n */\nexport function isValidLabel(label: string): boolean {\n  return /^[0-9A-Za-z_.-]+$/.test(label);\n}\n\n/**\n * validate for value\n *\n * @param value\n */\nexport function isValidValue(value: string): boolean {\n  // eslint-disable-next-line no-control-regex\n  return /^[\\x01-\\x08\\x0B\\x0C\\x0E-\\xFF]*$/.test(value);\n}\n","import type { LtsvRecord } from './types.js';\nimport { isValidLabel, isValidValue } from './validator.js';\n\ntype LtsvField = {\n  label: string;\n  value: string;\n};\n\n/**\n * split to label and value from field\n *\n * @private\n * @param chunk\n * @param strict\n * @throws {SyntaxError}\n * @throws {TypeError}\n */\nfunction splitField(chunk: string | undefined, strict: boolean): LtsvField {\n  if (chunk === undefined) {\n    throw new TypeError('chunk is undefined');\n  }\n\n  const index = chunk.indexOf(':');\n\n  if (index === -1) {\n    throw new SyntaxError(`field separator is not found: \"${chunk}\"`);\n  }\n\n  const label = chunk.slice(0, index);\n  const value = chunk.slice(index + 1);\n\n  if (strict && !isValidLabel(label)) {\n    throw new SyntaxError(`unexpected character in label: \"${label}\"`);\n  }\n\n  if (strict && !isValidValue(value)) {\n    throw new SyntaxError(`unexpected character in value: \"${value}\"`);\n  }\n\n  return {\n    label,\n    value\n  };\n}\n\n/**\n * parse LTSV record\n *\n * @private\n * @param line\n * @param strict\n */\nfunction baseParseLine(line: string | undefined, strict: boolean): LtsvRecord {\n  const fields = String(line)\n    .replace(/(?:\\r?\\n)+$/, '')\n    .split('\\t');\n\n  const record: LtsvRecord = {};\n\n  for (let i = 0, len = fields.length; i < len; ++i) {\n    const { label, value } = splitField(fields[i], strict);\n\n    record[label] = value;\n  }\n\n  return record;\n}\n\n/**\n * parse LTSV text\n *\n * @private\n * @param text\n * @param strict\n */\nfunction baseParse(text: string, strict: boolean): LtsvRecord[] {\n  const lines = String(text)\n    .replace(/(?:\\r?\\n)+$/, '')\n    .split(/\\r?\\n/);\n\n  const records: LtsvRecord[] = [];\n\n  for (let i = 0, len = lines.length; i < len; ++i) {\n    records[i] = baseParseLine(lines[i], strict);\n  }\n\n  return records;\n}\n\n/**\n * parse LTSV text\n *\n * @param text\n */\nexport function parse(text: string): LtsvRecord[] {\n  return baseParse(text, false);\n}\n\n/**\n * parse LTSV record\n *\n * @param line\n */\nexport function parseLine(line: string): LtsvRecord {\n  return baseParseLine(line, false);\n}\n\n/**\n * parse LTSV text\n *\n * @param text\n */\nexport function parseStrict(text: string): LtsvRecord[] {\n  return baseParse(text, true);\n}\n\n/**\n * parse LTSV record\n *\n * @param line\n */\nexport function parseLineStrict(line: string): LtsvRecord {\n  return baseParseLine(line, true);\n}\n","import { Transform, type TransformCallback } from 'stream';\nimport { StringDecoder } from 'string_decoder';\n\nimport { parseLine, parseLineStrict } from './parser.js';\nimport type { LtsvRecord } from './types.js';\n\nexport type LtsvToJsonStreamOptions = {\n  encoding?: BufferEncoding;\n  objectMode?: boolean;\n  strict?: boolean;\n};\n\n/**\n * LTSV to JSON transform stream\n */\nexport class LtsvToJsonStream extends Transform {\n  /**\n   * chunk buffer\n   */\n  buffer: string;\n  /**\n   * for decode chunks\n   */\n  decoder: StringDecoder;\n  /**\n   * if true, pass object to next stream\n   */\n  objectMode: boolean;\n  /**\n   * parser function\n   */\n  parse: typeof parseLine | typeof parseLineStrict;\n\n  /**\n   * constructor\n   *\n   * @param options\n   */\n  constructor(\n    options: LtsvToJsonStreamOptions = {\n      encoding: 'utf8',\n      objectMode: false,\n      strict: false\n    }\n  ) {\n    super({\n      ...options,\n      decodeStrings: true,\n      objectMode: true\n    });\n\n    const { encoding = 'utf8', objectMode = false, strict = false } = options;\n\n    this.objectMode = objectMode;\n    this.parse = strict ? parseLineStrict : parseLine;\n\n    this.buffer = '';\n    this.decoder = new StringDecoder(encoding);\n  }\n\n  /**\n   * transform and push to stream.\n   *\n   * @private\n   * @param text\n   * @param isFlush\n   * @param callback\n   */\n  _push(text: string, isFlush: boolean, callback: TransformCallback): void {\n    let next = 0;\n    let last = 0;\n    let error: Error | null = null;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      let index = text.indexOf('\\n', next);\n\n      if (index === -1) {\n        if (isFlush && next < text.length) {\n          // NOTE: subtract 1 from text.length,\n          // NOTE: because add 1 to index when slice.\n          index = text.length - 1;\n        } else {\n          break;\n        }\n      }\n\n      // NOTE: include `\\n`.\n      // NOTE: foo:foo\\tbar:bar\\nfoo:foo\\tbar:bar\\n\n      // NOTE: -----------------|\n      const line = text.slice(next, index + 1);\n\n      let record: LtsvRecord = {};\n\n      try {\n        record = this.parse(line);\n      } catch (e) {\n        if (e instanceof Error) {\n          error = e;\n        }\n      }\n\n      if (error) {\n        break;\n      }\n\n      const result = this.push(\n        this.objectMode ? record : JSON.stringify(record)\n      );\n\n      if (result) {\n        // NOTE: save next start index.\n        // NOTE: foo:foo\\tbar:bar\\nfoo:foo\\tbar:bar\\n\n        // NOTE: ------------------|\n        last = next = index + 1;\n      } else {\n        break;\n      }\n    }\n\n    this.buffer = text.slice(last);\n\n    callback(error);\n  }\n\n  /**\n   * _transform implementation.\n   *\n   * @private\n   * @param chunk\n   * @param encoding\n   * @param callback\n   */\n  override _transform(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    chunk: any,\n    _encoding: BufferEncoding,\n    callback: TransformCallback\n  ): void {\n    this._push(this.buffer + this.decoder.write(chunk), false, callback);\n  }\n\n  /**\n   * _flush implementation.\n   *\n   * @private\n   * @param callback\n   */\n  override _flush(callback: TransformCallback): void {\n    this._push(this.buffer + this.decoder.end(), true, callback);\n  }\n}\n\n/**\n * create LtsvToJsonStream instance.\n *\n * @param options\n * @see LtsvToJsonStream\n */\nexport function createLtsvToJsonStream(\n  options?: LtsvToJsonStreamOptions\n): LtsvToJsonStream {\n  return new LtsvToJsonStream(options);\n}\n"],"mappings":";;;;;;;;;;AAKA,SAAgB,aAAa,OAAwB;AACnD,QAAO,oBAAoB,KAAK,MAAM;;;;;;;AAQxC,SAAgB,aAAa,OAAwB;AAEnD,QAAO,kCAAkC,KAAK,MAAM;;;;;;;;;;;;;;ACCtD,SAAS,WAAW,OAA2B,QAA4B;AACzE,KAAI,UAAU,OACZ,OAAM,IAAI,UAAU,qBAAqB;CAG3C,MAAM,QAAQ,MAAM,QAAQ,IAAI;AAEhC,KAAI,UAAU,GACZ,OAAM,IAAI,YAAY,kCAAkC,MAAM,GAAG;CAGnE,MAAM,QAAQ,MAAM,MAAM,GAAG,MAAM;CACnC,MAAM,QAAQ,MAAM,MAAM,QAAQ,EAAE;AAEpC,KAAI,UAAU,CAAC,aAAa,MAAM,CAChC,OAAM,IAAI,YAAY,mCAAmC,MAAM,GAAG;AAGpE,KAAI,UAAU,CAAC,aAAa,MAAM,CAChC,OAAM,IAAI,YAAY,mCAAmC,MAAM,GAAG;AAGpE,QAAO;EACL;EACA;EACD;;;;;;;;;AAUH,SAAS,cAAc,MAA0B,QAA6B;CAC5E,MAAM,SAAS,OAAO,KAAK,CACxB,QAAQ,eAAe,GAAG,CAC1B,MAAM,IAAK;CAEd,MAAM,SAAqB,EAAE;AAE7B,MAAK,IAAI,IAAI,GAAG,MAAM,OAAO,QAAQ,IAAI,KAAK,EAAE,GAAG;EACjD,MAAM,EAAE,OAAO,UAAU,WAAW,OAAO,IAAI,OAAO;AAEtD,SAAO,SAAS;;AAGlB,QAAO;;;;;;;AAsCT,SAAgB,UAAU,MAA0B;AAClD,QAAO,cAAc,MAAM,MAAM;;;;;;;AAiBnC,SAAgB,gBAAgB,MAA0B;AACxD,QAAO,cAAc,MAAM,KAAK;;;;;;;;AC3GlC,IAAa,mBAAb,cAAsCA,iBAAU;;;;CAI9C;;;;CAIA;;;;CAIA;;;;CAIA;;;;;;CAOA,YACE,UAAmC;EACjC,UAAU;EACV,YAAY;EACZ,QAAQ;EACT,EACD;AACA,QAAM;GACJ,GAAG;GACH,eAAe;GACf,YAAY;GACb,CAAC;EAEF,MAAM,EAAE,WAAW,QAAQ,aAAa,OAAO,SAAS,UAAU;AAElE,OAAK,aAAa;AAClB,OAAK,QAAQ,SAAS,kBAAkB;AAExC,OAAK,SAAS;AACd,OAAK,UAAU,IAAIC,6BAAc,SAAS;;;;;;;;;;CAW5C,MAAM,MAAc,SAAkB,UAAmC;EACvE,IAAI,OAAO;EACX,IAAI,OAAO;EACX,IAAI,QAAsB;AAG1B,SAAO,MAAM;GACX,IAAI,QAAQ,KAAK,QAAQ,MAAM,KAAK;AAEpC,OAAI,UAAU,GACZ,KAAI,WAAW,OAAO,KAAK,OAGzB,SAAQ,KAAK,SAAS;OAEtB;GAOJ,MAAM,OAAO,KAAK,MAAM,MAAM,QAAQ,EAAE;GAExC,IAAI,SAAqB,EAAE;AAE3B,OAAI;AACF,aAAS,KAAK,MAAM,KAAK;YAClB,GAAG;AACV,QAAI,aAAa,MACf,SAAQ;;AAIZ,OAAI,MACF;AAOF,OAJe,KAAK,KAClB,KAAK,aAAa,SAAS,KAAK,UAAU,OAAO,CAClD,CAMC,QAAO,OAAO,QAAQ;OAEtB;;AAIJ,OAAK,SAAS,KAAK,MAAM,KAAK;AAE9B,WAAS,MAAM;;;;;;;;;;CAWjB,AAAS,WAEP,OACA,WACA,UACM;AACN,OAAK,MAAM,KAAK,SAAS,KAAK,QAAQ,MAAM,MAAM,EAAE,OAAO,SAAS;;;;;;;;CAStE,AAAS,OAAO,UAAmC;AACjD,OAAK,MAAM,KAAK,SAAS,KAAK,QAAQ,KAAK,EAAE,MAAM,SAAS;;;;;;;;;AAUhE,SAAgB,uBACd,SACkB;AAClB,QAAO,IAAI,iBAAiB,QAAQ"}