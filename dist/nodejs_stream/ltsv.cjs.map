{"version":3,"file":"ltsv.cjs","sources":["../../src/validator.ts","../../src/parser.ts","../../src/nodejs_stream.ts"],"sourcesContent":["/**\n * validate label\n *\n * @param label\n */\nexport function isValidLabel(label: string): boolean {\n  return /^[0-9A-Za-z_.-]+$/.test(label);\n}\n\n/**\n * validate for value\n *\n * @param value\n */\nexport function isValidValue(value: string): boolean {\n  // eslint-disable-next-line no-control-regex\n  return /^[\\x01-\\x08\\x0B\\x0C\\x0E-\\xFF]*$/.test(value);\n}\n","import type { LtsvRecord } from './types.js';\nimport { isValidLabel, isValidValue } from './validator.js';\n\ntype LtsvField = {\n  label: string;\n  value: string;\n};\n\n/**\n * split to label and value from field\n *\n * @private\n * @param chunk\n * @param strict\n * @throws {SyntaxError}\n * @throws {TypeError}\n */\nfunction splitField(chunk: string | undefined, strict: boolean): LtsvField {\n  if (chunk === undefined) {\n    throw new TypeError('chunk is undefined');\n  }\n\n  const index = chunk.indexOf(':');\n\n  if (index === -1) {\n    throw new SyntaxError(`field separator is not found: \"${chunk}\"`);\n  }\n\n  const label = chunk.slice(0, index);\n  const value = chunk.slice(index + 1);\n\n  if (strict && !isValidLabel(label)) {\n    throw new SyntaxError(`unexpected character in label: \"${label}\"`);\n  }\n\n  if (strict && !isValidValue(value)) {\n    throw new SyntaxError(`unexpected character in value: \"${value}\"`);\n  }\n\n  return {\n    label,\n    value\n  };\n}\n\n/**\n * parse LTSV record\n *\n * @private\n * @param line\n * @param strict\n */\nfunction baseParseLine(line: string | undefined, strict: boolean): LtsvRecord {\n  const fields = String(line)\n    .replace(/(?:\\r?\\n)+$/, '')\n    .split('\\t');\n\n  const record: LtsvRecord = {};\n\n  for (let i = 0, len = fields.length; i < len; ++i) {\n    const { label, value } = splitField(fields[i], strict);\n\n    record[label] = value;\n  }\n\n  return record;\n}\n\n/**\n * parse LTSV text\n *\n * @private\n * @param text\n * @param strict\n */\nfunction baseParse(text: string, strict: boolean): LtsvRecord[] {\n  const lines = String(text)\n    .replace(/(?:\\r?\\n)+$/, '')\n    .split(/\\r?\\n/);\n\n  const records: LtsvRecord[] = [];\n\n  for (let i = 0, len = lines.length; i < len; ++i) {\n    records[i] = baseParseLine(lines[i], strict);\n  }\n\n  return records;\n}\n\n/**\n * parse LTSV text\n *\n * @param text\n */\nexport function parse(text: string): LtsvRecord[] {\n  return baseParse(text, false);\n}\n\n/**\n * parse LTSV record\n *\n * @param line\n */\nexport function parseLine(line: string): LtsvRecord {\n  return baseParseLine(line, false);\n}\n\n/**\n * parse LTSV text\n *\n * @param text\n */\nexport function parseStrict(text: string): LtsvRecord[] {\n  return baseParse(text, true);\n}\n\n/**\n * parse LTSV record\n *\n * @param line\n */\nexport function parseLineStrict(line: string): LtsvRecord {\n  return baseParseLine(line, true);\n}\n","import { Transform, type TransformCallback } from 'stream';\nimport { StringDecoder } from 'string_decoder';\n\nimport { parseLine, parseLineStrict } from './parser.js';\nimport type { LtsvRecord } from './types.js';\n\nexport type LtsvToJsonStreamOptions = {\n  encoding?: BufferEncoding;\n  objectMode?: boolean;\n  strict?: boolean;\n};\n\n/**\n * LTSV to JSON transform stream\n */\nexport class LtsvToJsonStream extends Transform {\n  /**\n   * chunk buffer\n   */\n  buffer: string;\n  /**\n   * for decode chunks\n   */\n  decoder: StringDecoder;\n  /**\n   * if true, pass object to next stream\n   */\n  objectMode: boolean;\n  /**\n   * parser function\n   */\n  parse: typeof parseLine | typeof parseLineStrict;\n\n  /**\n   * constructor\n   *\n   * @param options\n   */\n  constructor(\n    options: LtsvToJsonStreamOptions = {\n      encoding: 'utf8',\n      objectMode: false,\n      strict: false\n    }\n  ) {\n    super({\n      ...options,\n      decodeStrings: true,\n      objectMode: true\n    });\n\n    const { encoding = 'utf8', objectMode = false, strict = false } = options;\n\n    this.objectMode = objectMode;\n    this.parse = strict ? parseLineStrict : parseLine;\n\n    this.buffer = '';\n    this.decoder = new StringDecoder(encoding);\n  }\n\n  /**\n   * transform and push to stream.\n   *\n   * @private\n   * @param text\n   * @param isFlush\n   * @param callback\n   */\n  _push(text: string, isFlush: boolean, callback: TransformCallback): void {\n    let next = 0;\n    let last = 0;\n    let error: Error | null = null;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      let index = text.indexOf('\\n', next);\n\n      if (index === -1) {\n        if (isFlush && next < text.length) {\n          // NOTE: subtract 1 from text.length,\n          // NOTE: because add 1 to index when slice.\n          index = text.length - 1;\n        } else {\n          break;\n        }\n      }\n\n      // NOTE: include `\\n`.\n      // NOTE: foo:foo\\tbar:bar\\nfoo:foo\\tbar:bar\\n\n      // NOTE: -----------------|\n      const line = text.slice(next, index + 1);\n\n      let record: LtsvRecord = {};\n\n      try {\n        record = this.parse(line);\n      } catch (e) {\n        if (e instanceof Error) {\n          error = e;\n        }\n      }\n\n      if (error) {\n        break;\n      }\n\n      const result = this.push(\n        this.objectMode ? record : JSON.stringify(record)\n      );\n\n      if (result) {\n        // NOTE: save next start index.\n        // NOTE: foo:foo\\tbar:bar\\nfoo:foo\\tbar:bar\\n\n        // NOTE: ------------------|\n        last = next = index + 1;\n      } else {\n        break;\n      }\n    }\n\n    this.buffer = text.slice(last);\n\n    callback(error);\n  }\n\n  /**\n   * _transform implementation.\n   *\n   * @private\n   * @param chunk\n   * @param encoding\n   * @param callback\n   */\n  override _transform(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    chunk: any,\n    _encoding: BufferEncoding,\n    callback: TransformCallback\n  ): void {\n    this._push(this.buffer + this.decoder.write(chunk), false, callback);\n  }\n\n  /**\n   * _flush implementation.\n   *\n   * @private\n   * @param callback\n   */\n  override _flush(callback: TransformCallback): void {\n    this._push(this.buffer + this.decoder.end(), true, callback);\n  }\n}\n\n/**\n * create LtsvToJsonStream instance.\n *\n * @param options\n * @see LtsvToJsonStream\n */\nexport function createLtsvToJsonStream(\n  options?: LtsvToJsonStreamOptions\n): LtsvToJsonStream {\n  return new LtsvToJsonStream(options);\n}\n"],"names":["isValidLabel","label","test","isValidValue","value","splitField","chunk","strict","undefined","TypeError","index","indexOf","SyntaxError","slice","baseParseLine","line","fields","String","replace","split","record","i","len","length","parseLine","parseLineStrict","LtsvToJsonStream","Transform","constructor","options","encoding","objectMode","decodeStrings","buffer","decoder","parse","StringDecoder","_push","text","isFlush","callback","next","last","error","e","Error","result","push","JSON","stringify","_transform","_encoding","write","_flush","end","createLtsvToJsonStream"],"mappings":"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"}