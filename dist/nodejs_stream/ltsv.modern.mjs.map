{"version":3,"file":"ltsv.modern.mjs","sources":["../../src/validator.ts","../../src/parser.ts","../../src/nodejs_stream.ts"],"sourcesContent":["/**\n * validate label\n *\n * @param label\n */\nexport function isValidLabel(label: string): boolean {\n  return /^[0-9A-Za-z_.-]+$/.test(label);\n}\n\n/**\n * validate for value\n *\n * @param value\n */\nexport function isValidValue(value: string): boolean {\n  // eslint-disable-next-line no-control-regex\n  return /^[\\x01-\\x08\\x0B\\x0C\\x0E-\\xFF]*$/.test(value);\n}\n","import { isValidLabel, isValidValue } from './validator';\n\nimport { LtsvRecord } from './types';\n\ntype LtsvField = {\n  label: string;\n  value: string;\n};\n\n/**\n * split to label and value from field\n *\n * @private\n * @param chunk\n * @param strict\n * @throws {SyntaxError}\n */\nfunction splitField(chunk: string, strict: boolean): LtsvField {\n  const field = String(chunk);\n  const index = field.indexOf(':');\n\n  if (index === -1) {\n    throw new SyntaxError(`field separator is not found: \"${field}\"`);\n  }\n\n  const label = field.slice(0, index);\n  const value = field.slice(index + 1);\n\n  if (strict && !isValidLabel(label)) {\n    throw new SyntaxError(`unexpected character in label: \"${label}\"`);\n  }\n\n  if (strict && !isValidValue(value)) {\n    throw new SyntaxError(`unexpected character in value: \"${value}\"`);\n  }\n\n  return {\n    label,\n    value\n  };\n}\n\n/**\n * parse LTSV record\n *\n * @private\n * @param line\n * @param strict\n */\nfunction baseParseLine(line: string, strict: boolean): LtsvRecord {\n  const fields = String(line)\n    .replace(/(?:\\r?\\n)+$/, '')\n    .split('\\t');\n\n  const record: LtsvRecord = {};\n\n  for (let i = 0, len = fields.length; i < len; ++i) {\n    const { label, value } = splitField(fields[i], strict);\n\n    record[label] = value;\n  }\n\n  return record;\n}\n\n/**\n * parse LTSV text\n *\n * @private\n * @param text\n * @param strict\n */\nfunction baseParse(text: string, strict: boolean): LtsvRecord[] {\n  const lines = String(text)\n    .replace(/(?:\\r?\\n)+$/, '')\n    .split(/\\r?\\n/);\n\n  const records: LtsvRecord[] = [];\n\n  for (let i = 0, len = lines.length; i < len; ++i) {\n    records[i] = baseParseLine(lines[i], strict);\n  }\n\n  return records;\n}\n\n/**\n * parse LTSV text\n *\n * @param text\n */\nexport function parse(text: string): LtsvRecord[] {\n  return baseParse(text, false);\n}\n\n/**\n * parse LTSV record\n *\n * @param line\n */\nexport function parseLine(line: string): LtsvRecord {\n  return baseParseLine(line, false);\n}\n\n/**\n * parse LTSV text\n *\n * @param text\n */\nexport function parseStrict(text: string): LtsvRecord[] {\n  return baseParse(text, true);\n}\n\n/**\n * parse LTSV record\n *\n * @param line\n */\nexport function parseLineStrict(line: string): LtsvRecord {\n  return baseParseLine(line, true);\n}\n","import { Transform, TransformCallback } from 'stream';\nimport { StringDecoder } from 'string_decoder';\n\nimport { parseLine, parseLineStrict } from './parser';\nimport { LtsvRecord } from './types';\n\nexport type LtsvToJsonStreamOptions = {\n  encoding?: string;\n  objectMode?: boolean;\n  strict?: boolean;\n};\n\n/**\n * LTSV to JSON transform stream\n */\nexport class LtsvToJsonStream extends Transform {\n  /**\n   * chunk buffer\n   */\n  buffer: string;\n  /**\n   * for decode chunks\n   */\n  decoder: StringDecoder;\n  /**\n   * if true, pass object to next stream\n   */\n  objectMode: boolean;\n  /**\n   * parser function\n   */\n  parse: typeof parseLine | typeof parseLineStrict;\n\n  /**\n   * constructor\n   *\n   * @param options\n   */\n  constructor(\n    options: LtsvToJsonStreamOptions = {\n      encoding: 'utf8',\n      objectMode: false,\n      strict: false\n    }\n  ) {\n    super({\n      ...options,\n      decodeStrings: true,\n      objectMode: true\n    });\n\n    const { encoding = 'utf8', objectMode = false, strict = false } = options;\n\n    this.objectMode = objectMode;\n    this.parse = strict ? parseLineStrict : parseLine;\n\n    this.buffer = '';\n    this.decoder = new StringDecoder(encoding);\n  }\n\n  /**\n   * transform and push to stream.\n   *\n   * @private\n   * @param text\n   * @param isFlush\n   * @param callback\n   */\n  _push(text: string, isFlush: boolean, callback: TransformCallback): void {\n    let next = 0;\n    let last = 0;\n    let error: Error | null = null;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      let index = text.indexOf('\\n', next);\n\n      if (index === -1) {\n        if (isFlush && next < text.length) {\n          // NOTE: subtract 1 from text.length,\n          // NOTE: because add 1 to index when slice.\n          index = text.length - 1;\n        } else {\n          break;\n        }\n      }\n\n      // NOTE: include `\\n`.\n      // NOTE: foo:foo\\tbar:bar\\nfoo:foo\\tbar:bar\\n\n      // NOTE: -----------------|\n      const line = text.slice(next, index + 1);\n\n      let record: LtsvRecord = {};\n\n      try {\n        record = this.parse(line);\n      } catch (e) {\n        if (e instanceof Error) {\n          error = e;\n        }\n      }\n\n      if (error) {\n        break;\n      }\n\n      const result = this.push(\n        this.objectMode ? record : JSON.stringify(record)\n      );\n\n      if (result) {\n        // NOTE: save next start index.\n        // NOTE: foo:foo\\tbar:bar\\nfoo:foo\\tbar:bar\\n\n        // NOTE: ------------------|\n        last = next = index + 1;\n      } else {\n        break;\n      }\n    }\n\n    this.buffer = text.slice(last);\n\n    callback(error);\n  }\n\n  /**\n   * _transform implementation.\n   *\n   * @private\n   * @param chunk\n   * @param encoding\n   * @param callback\n   */\n  _transform(\n    chunk: Buffer,\n    encoding: string,\n    callback: TransformCallback\n  ): void {\n    this._push(this.buffer + this.decoder.write(chunk), false, callback);\n  }\n\n  /**\n   * _flush implementation.\n   *\n   * @private\n   * @param callback\n   */\n  _flush(callback: TransformCallback): void {\n    this._push(this.buffer + this.decoder.end(), true, callback);\n  }\n}\n\n/**\n * create LtsvToJsonStream instance.\n *\n * @param options\n * @see LtsvToJsonStream\n */\nexport function createLtsvToJsonStream(\n  options?: LtsvToJsonStreamOptions\n): LtsvToJsonStream {\n  return new LtsvToJsonStream(options);\n}\n"],"names":["isValidLabel","label","test","isValidValue","value","splitField","chunk","strict","field","String","index","indexOf","SyntaxError","slice","baseParseLine","line","fields","replace","split","record","i","len","length","parseLine","parseLineStrict","LtsvToJsonStream","Transform","constructor","options","encoding","objectMode","_extends","decodeStrings","buffer","decoder","parse","StringDecoder","_push","text","isFlush","callback","next","last","error","e","Error","result","push","JSON","stringify","_transform","write","_flush","end","createLtsvToJsonStream"],"mappings":"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"}